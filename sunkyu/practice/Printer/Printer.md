# [프린터](https://programmers.co.kr/learn/courses/30/lessons/42587)

## 문제 설명

- 프린터는 인쇄 요청이 들어온 순서대로 인쇄
- 중요한 문서가 나중에 인괘될 수 있다.
- 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발
- 다음의 방식으로 인쇄 작업을 수행
  1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
  2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
  3. 그렇지 않으면 J를 인쇄합니다.

- 4개의 문서 (A, B, C, D)가 순서대로 있고 중요도가 (2, 1, 3, 2)라면 C D A B 순서대로 인쇄
- 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 
- 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때,
- 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return

## 제한 사항

- 현재 대기목록에는 1개 이상 100개 이하의 문서
- 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요
- location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며
- 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현

## 입출력 예

| priorities         | location | return |
|--------------------|----------|--------|
| [2, 1, 3, 2]       | 2        | 1      |
| [1, 1, 9, 1, 1, 1] | 0        | 5      |

## 풀이 아이디어

- 연산하기 편하게 딕셔너리를 사용하여 priority에 index를 추가해줌
- 딕셔너리를 사용하면 중복되는 우선순위가 반영되지 않아 이차원 리스트를 사용
- 최우선순위를 찾고 맨 앞과 비교후 pop해서 하니씩 뒤로 보낸다
- 아니라면 인쇄하고, 인쇄한 문서가 내가 찾는 문서라면 리턴

## 풀이 코드

```python
def solution(priorities, location):
    queue = []
    ans = 0
    
    for i in range(len(priorities)):
        queue.append([priorities[i], i])
    
    while True:
        if max(queue)[0] > queue[0][0]:
            queue.append(queue.pop(0))
        else:
            ans += 1
            printer = queue.pop(0)[1]
            if printer == location:
              return ans  
```