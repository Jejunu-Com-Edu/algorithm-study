# 최단경로
말 그대로 가장 짧은 경로를 찾는 알고리즘, 그래서 "길 찾기" 문제라고도 불림.

## 가장 빠르게 도달하는 방법
- 최단 경로 문제는 보통 그래프를 이용해 표햔하는데 각 지점은 그래프에서 "노드"로 표현되고, 지점간 연결되 도로는 그래프에서 "간선"으로 표현된다.

- 실제 코딩 테스트에서는 최단 경로를 모두 출력하는 문제보다는 단순히 최단 거리를 출력하도록 요구하는 문제가 많이 출제됨.

- 다익스트라 최단 경로와 플로이드 워셜 알고리즘이 고테에서 가장 많이 등장 하는 유형

- 더불어 앞서 공부한 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 그대로 적용된다는 특징이 있음.
=>> 다시 말해 이번 장에서 배우는 내용은 사실 그리디 알고리즘 및 다이나믹 프로그래밍 알고리즘의 한 유형

## 다익스트라 최단 경로 알고리즘
```
  그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다. 다익스트라 최단 경로 알고리즘은 "음의 간선"이 없을 때 정상적으로 동작한다. 음의 간선이란 0보다 작은 값을 가지는 간선을 의미하는데, 현실 세계의 길(간선)은 음의 간선으로 표현되지 않으므로 다익스트라 알고리즘은 실제로 GPS소프트웨어의 기본 알고리즘으로 채택한다
```

- 다익스트라 알고리즘은 기본적으로 그리디 알고리즘으로 분류됨. " 매번 가장 비용이 적은 노드"를 선택해서 임의의 과정을 반복

1) 출발 노드를 설정
2) 최단 거리 테이블을 초기화
3) 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
4) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5) 위 과정에서 3번과 4번을 반복

<br>

- 다익스트라 알고리즘은 최단 경로를 구하는 과정에서 "각 노드에 대한 현재까지의 최단 거리" 정보를 항상 1차원 리스트(최단 거리 테이블)에 저장하며 리스트를 계속 갱신한다는 특징이 있음.

- 매번 현재 처리하고 있는 노드를 기준으로 주변 간선을 확인한다. 나중에 현재 처리하고 있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면 "더 짧은 경로도 있었네? 이제부터는 이 경로가 제일 짧은 경로야" 라고 판단함.

- 따라서 방문하지 않은 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인해 그 노드에 대하여 4번 과정을 수행한다는 점에서 그리디 알고리즘으로 볼 수 있음.

- 다익스트라 최단 경로 알고리즘에서는 "방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택"하는 과정을 반복하는데, 이렇게 선택된 노드는 "최단 거리"가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않음.

```
즉 다시 말해 다익스트라 알고리즘이 진행되면서 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있음.
```

- 그렇기 때문에, 사실 마지막 노드에 대해서는 해당 노드를 거쳐 다른 노드로 가는 경우를 확인할 필요가 없음.

## 방법1. 간단한 다익스트라 알고리즘
 - 시간 복잡도 : O(v제곱) 여기서 v는 노드의 계수
 ```
 처음에 각 노드에 대한 최단 거리를 담는 1차원 리스트를 선언함. 이후에 단계마다 " 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택" 하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인(순차탐색)
```

 ```js
function solution(start, input){
    // 무한의 수 대신 10억
    INF = 1e9;

    //노드 개수
    const N = input.shift();
    //간선 개수
    const M = input.shift();

    // 각 노드에 연결 된 간선 정보 담는 배열
    const graph = Array.from(Array(N+1), () => new Array())
    // 방문한 적 있는지 체크하는 배열
    const visited = Array.from(Array(N+1), () => false);
    // 최단 거리 테이블. 무한으로 초기화
    const distance = Array.from(Array(N+1), ()=> INF);

    //모든 간선 정보 입력
    for(let i = 0; i < M; i++){
      [a, b, c] = input[i].split(' ').map(Number);
      graph[a].push([b , c]);
    }

    // 다익스트라 알고리즘 실행
    dijkstra(INF, N, graph, distance, visited, start);
    console.log('finish')
}

function dijkstra(INF, N, graph, distance, visited, start){
    distance[start] = 0;
    visited[start] = true;

    graph[start].map(v =>{
        distance[v[0]] = v[1];
    })

    // 시작 노드 제외한 전체 n-1 개의 노드에 대해 반복
    for(let i = 0; i < N; i++){
        //현재 최단 거리가 가장 짧은 노드 꺼내서 방문처리
        const now = getSmallestNode(INF, N, distance, visited);
        visited[now] = true;

        // 현재 노드와 연결된 다른 노드 확인
        graph[now].map(v =>{
            let cost = distance[now] + v[1];
            distance[v[0]] = Math.min(cost, distance[v[0]]);
        })
    }

    // 모든 노드 가기 위한 최단 거리 출력
    for(let i = 1; i < N+1; i++){
        distance[i] === INF ? console.log('무한') : console.log(distance[i]);
    }
}

//방문하지 않은 노드 중 가장 짧은 노드 번호 반환
function getSmallestNode(INF, N, distance, visited) {
    min_value = INF;
    index = 0; // 가장 최단거리가 짧은 노드 인덱스
    for(let i = 1; i <= N; i++){
        if(distance[i] < min_value && visited[i] === false){
            min_value = distance[i];
            index = i;
        }
    }
    return index;
}
const start = 1;
const input = [6, 11,
'1 2 2',
'1 4 1',
'1 3 5',
'2 3 3',
'2 4 2',
'3 2 3',
'3 6 5',
'4 3 3',
'4 5 1',
'5 3 1',
'5 6 2'];
solution(start, input);
 ```

 - 시간 복잡도 O(v제곱). 왜냐하면 총 O(v)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야 하고, 현재 노드와 연결된 노드를 매번 일일이 확인하기 때문임. 

=> 따라서 코테에서 전체 노드의 개수가 5,000개 이하라며 위와 같은 식으로 풀이가 가능
하지만 노드의 개수가 10,000개를 넘어가는 문제라면 이 코드로는 불가능

## 방법2. 개선된 다익스트라 알고리즘
- 개선된 다익스트라 알고리즘의 시간복잡도는 O(ElogV)를 보장

- 간단한 다익스트라 알고리즘은 '최단거리가 가장 짧은 노드"를 찾기 위해서, 매번 최단 거리 테이블을 선형적으로(모든 원소를 앞에서부터 하나씩) 탐색해야 했음. 하지만 최단 거리가 가장 짧은 노드를 단순히 선형적으로 찾는 것이 아니라 더욱더 빠르게 찾을 수 있다면?

- 개선된 다익스트라 자료구조는 힙(Heap)자료구조를 사용한다. 힙 자료구조를 이용하게 되면 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리하므로 출발 노드로부터 가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다. 이 과정에서 선형 시간이 아닌 log 시간이 걸림.

## 힙 설명
- 힙 자료구조는 우선순위 큐(Priority queue)를 구현하기 위하여 사용하는 자료구조 중 하나

- 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제 한다는 특징

   - 자료구조/ 추출되는 데이터
   - 스택 / 가장 나중에 삽입된 데이터
   - 큐 / 가장 먼저 삽입된 데이터
   - 우선순위 큐 / 가장 우선순위가 높은 데이터

- 우선순위 큐는 데이터를 우선순위에 따라 처리하고 싶을 때 사용
```js
const graph = []; // 노드 연결 정보를 포함한 그래프로 [Node, distance] 값을 가짐.
let distance = []; // 노드 최단거리 배열
const visited = []; // 노드 방문 배열
const N = 10000; // 노드 갯수

class PriorityQueue {
  // pq 구현하기
  // method : push, pop
}

function initDistance(start) {
  distance = new Array(N).fill(10001);
  distance[start] = 0;
}

function improvedDijkstra(start) {
  const pq = new PriorityQueue();
  // 시작 노드로 가기 위한 최단 경로는 0으로 설정, 큐에 삽입
  pq.push([0, start]);
  distance[start] = 0;

  while (pq.length) {
    //가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
    const [dist, now] = pq.pop(); 
    // 현재 노드가 이미 처리된 적이 있는 노드라면 무시
    if (distance[now] < dist) continue;
    // 현재 노드와 연결된 다른 인접한 노드들을 확인
    for (let [nextNode, nextDist] of graph[now]) {
      const cost = dist + nextDist;
    // 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
      if (cost < distance[nextNode]) {
        distance[nextNode] = cost;
        pq.push([cost, nextNode]);
      }
    }
  }
// 개선된 다익스트라 : 시간복잡도 O(ElogV)이며, E=간선 개수, V=노드 개수
// 최단거리가 가장 짧은 노드를 '힙 자료구조'를 이용해 찾음.
// 힙 자료구조는 우선순위 큐 구현에 사용함

// 최소 힙은 값이 낮은 데이터가 먼저 삭제, 최대 힙은 값이 높은 데이터가 먼저 삭제됨.
// 최소 힙을 최대 힙처럼 사용하기 위해선, 값에 음 부호를 부여하고 꺼낼 때 다시 음수 부호를 부여하면 됨.
```

## 플로이드 워셜 알고리즘
- 다익스트라 알고리즘은 "한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우"에 사용할 수 있는 최단 경로 알고리즘"

```
플로이드 워셜 알고리즘은 모든 지점에서 다른 모든 지점까지의 최단 경로를 구해야 하는 경우 사용할 수 있는 알고리즘

- 모든 최단 경로를 구하는 알고리즘
다익스트라는 하나의 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘(S.S.S.P - Single Source Shortest Path) 이었다면, 플로이드-워셜 알고리즘은 한 번 실행하여 모든 노드 간 최단 경로를 구할 수 있습니다.

- 플로이드-워셜 알고리즘은 다익스트라 알고리즘과는 다르게 음의 간선도 사용할 수 있다.

플로이드-워셜 알고리즘의 과정
- 모든 노드 간의 최단거리를 구해야 하므로 2차원 인접 행렬을 구성합니다. 알고리즘은 여러 라운드로 구성됩니다. 라운드마다 각 경로에서 새로운 중간 노드로 사용할 수 있는 노드를 선택하고, 더 짧은 길이를 선택하여 줄이는 과정을 반복합니다.
```

- 2차원 리스트에 최단 거리 정보를 저장함

- 플로이드워셜 알고리즘의 경우 다이나믹프로그래밍

```
Dab = min(Dab, Dak + Dkb)
A에서 B로 가는 최소 비용과 A에서 K를 거쳐 B로 가는 비용을 비교하여 더 작은 값으로 갱신
```
```js
function solution(input){

    let INF = 1e9; //10억. 무한 대신 10억 사용.

    // 노드 개수 입력
    const N = input.shift();
    // 간선 개수 입력
    const M = input.shift();
    // 2차원 배열 10억으로 초기화
    const graph = Array.from(Array(N+1), () => Array(N+1).fill(INF));
    // 자기 자신으로 가는 비용은 0으로 초기화
    for(let i = 1; i <= N; i++){
        for(let j = 1; j <= N; j++){
            if(i === j) graph[i][j] = 0;
        }
    }
    console.log(graph)
    //각 간선에 대한 정보 받아 그 값으로 초기화
    for(let i = 0; i < M; i++){
        [a, b, c] = input[i].split(' ');
        graph[a][b] = c;
    }

    //플로이드 워셜 알고리즘 실행
    // k = 거쳐가는 노드(거쳐가는 노드가 기준)
    for(let k = 1; k <= N; k++){
        //a = 출발 노드(모든정점 다 방문)
        for(let a = 1; a <= N; a++){
            //b = 도착 노드
            for(let b = 1; b <= N; b++){
                //a-b로 가는 비용 a-k 가는 비용이 더적으면 더 적은비용으로 갱신
                graph[a][b] = Math.min(graph[a][b], graph[a][k] + graph[k][b]);
            }
        }
    }

    for(let a = 1; a <= N; a++){
        for(let b = 1; b <= N; b++){
            graph[a][b] === INF ? console.log('무한') : console.log(graph[a][b])
        }
    }
    
}

const input = [ 4, 7, 
'1 2 4',
'1 4 6',
'2 1 3',
'2 3 7',
'3 1 5',
'3 4 4',
'4 3 2'];

solution(input);
```

## 문제
N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다.

위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.
마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
- 마을의 개수 N은 1 이상 50 이하의 자연수입니다.
- road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.
- road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.
- road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.
    - a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.
    - 두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.
    - 한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.
- K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.
- 임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.
- 1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.


- 노드별 거리를 무한으로 하는 배열 생성(1붜 사용하기 위해 N+1의 배열 생성)
    인접한 노드별 시간(가중치)의 정보를 담고 있는 배열 생성
      - 인접한 노드별 시간(가중치)의 정보를 담고 있는 배열에 데이터 추가
- 1번 마을에서부터 우선순위 큐 시작 및 초기값 0 할당(시작점이기 때문에)
- 우선순위 큐 배열에 값이 없을 때까지 반복
- 연결된 노드에서의 값이 현재의 값 + 해당 노드의 시간(가중치) 보다 클 경우, 값을 대체하고 우선순위 큐에 데이터 추가
- K이하의 시간에 배달되는 값 filter

```js
function solution(N, road, K) {
    const dist = Array(N + 1).fill(Infinity);
    const adj = Array.from({ length: N + 1 }, () => []);

    road.forEach(([a,b,c]) => {        
        adj[a].push({ to: b, time: c }); 
        adj[b].push({ to: a, time: c }); 
    });

    const pq = [{ to: 1, time: 0 }];
    dist[1] = 0;

    while(pq.length) {
        let {to, time} = pq.pop();

        adj[to].forEach(next => {
            if(dist[next.to] > dist[to] + next.time) {
                dist[next.to] = dist[to] + next.time;
                pq.push(next);
            }
        })
    }

    return dist.filter((item) => item <= K ).length;
}
```
- 다익스트라 알고리즘을 이용하여 가중치를 가진 그래프에서 특정 정점을 시작점으로 나머지 모든 점들에 대한 최단거리를 구함