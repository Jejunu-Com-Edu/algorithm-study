# DFS / BFS
DFS : 깊이 우선 탐색, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

BFS : 너비 우선 탐색, 가까운 노트부터 탐색하는 알고리즘

<br>

## 탐색이란?
많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
 -> 대표적으로 DFS, BFS 문제를 꼽을 수 있는데 이해하기 위해서는 기본 자료구조인 스택, 큐에 대한 이해를 해야함

 ## 자료구조란?
 데이터를 표현하고 관리하고 처리하기 위한 구조
 
    삽입(Push) : 데이터를 삽입한다.
    삭제(Pop) : 데이터를 삭제한다.
      -> 실제로 스택과 큐를 사용할 때는 삽입, 삭제 외에도 오버플로와 언더플로도 고민해야 하는데 오버플로는 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입연산을 수행할 때 발생한다. 반면 언더플로는 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태일 때 발생한다.
<br>

## 스택(Stack)
스택은 박스 쌓기에 비유할 수 있다. 아래에서부터 위로 쌓고 아래 있는 박스를 치우기 위해서는 위에 박스를 차례대로 내려야 하는데 이러한 구조를 선입후출 또는 후입선출구조라고 한다. 


```js
class Stack{
  constructor() {
    this._arr = [];
  }
  push(item) {
    this._arr.push(item);
  }
  pop(){
    return this._arr.pop();
  }
  peek() {
    return this._arr[this._arr.length - 1];
  }
}

const stack = new Stack();
stack.push(3);
stack.push(2);
stack.push(1);
stack.pop();
console.log(stack);
```
<br>

## 큐(Queue)
큐는 대기 줄에 비유할 수 있다. 놀이공원에 입장하기 위해 줄을 설 때, 먼저 온 사람이 먼저 들어가게 되는데, 나중에 온 사람일수록 나중에 들어가기 때문에 선입선출 구조라고 한다.


```js
class Queue {
  constructor() {
    this._arr = [];
  }
  enqueue(item) {
    this._arr.push(item);
  }
  dequeue() {
    return this._arr.shift();
  }

  const queue = new Queue();
  queue.enqueue(3) ;
  queue.enqueue(2) ;
  queue.enqueue(1) ;
  queue.deque();
}
```
<br>

## 재귀함수(Recursive Function)
DFS/BFS를 구현하려면 재귀함수를 알아야 하는데 재귀함수란 자기 자신을 다시 호출하는 함수를 의미한다.


```js
function recursionFunc () {
  console.log('재귀 함수를 호출합니다.');
  recursionFunc();
  ...
}
```
나와 같은 이름의 함수를 내부에서 실행해 주는 것이다. 내가 만든 함수 내부에서 다시 나를 부르는 형태이기 때문에 무한히 계속 반복되는 함수가 되기 때문에 재귀함수를 만들 때에는 반드시 함수를 종료하는 조건을 만들어야 한다.

  ### 재귀함수의 종료 조건
  재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해야한다. 자칫 종료 조건을 명시하지 않으면 함수가 무한 호출될 수 있다. 대표적인 예로 팩토리얼 문제가 있다.

  ```js
  function factorial(num) {
    if (num < 1) {
      return 1;
    }
    return num * factorial(num -1);
  }

  const num = 5;
  let result = factorial(num);
  console.log('${num}! = ${result}');
  ```
재귀 함수를 사용했을 때 얻을 수 있는 장점은 재귀 함수의 코드가 더 간결한 것을 알 수 있다.

<br>

## DFS(Depth-First Search)
깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. 

![ex_node](/img/dfsbfs.webp)

그래프는 노드(node)와 간선(edge)으로 표현되며 이때 노드를 정점(vertex)이라고도 말한다. 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다. 또한 두 노드를 시작으로 다수의 노드를 방문하는 것을 말한다. 두 노드가 연결되어 있으면 인접하다 라도 표현한다. 그래프는 크게 2가지 방식으로 표현할 수 있다.
- 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
- 인접 리스트(Adjacency List) : 그래프로 그래프의 연결 관계를 표현하는 방식


인접행렬(Adjacency Matrix)방식은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다.(다른 언어의 배열을 파이썬에서는 리스트 자료형으로 표현할 수 있어서 파이썬은 인접 행렬을 리스트로 구현함.)

```js
let result = Matrix ([
  [0, 7, 5],
  [7, 0, INF],
  [5, INF, 0],
]);

console.log(result);
```

그렇다면 인접 리스트(Adjacency List)방식에서는 데이터를 어떤 방식으로 저장할까? 인접 리스트 방식은 연결리스트라는 자료구조를 이용해 구현한다. 
```js
class UndirectedGraph {
  constructor() {
    this.edges = {};
  }
  
  addVertex(vertex) {
    this.edges[vertex] = {}; 
  }


  addEdge(vertex1, vertex2, weight) {
    if (weight === undefined) {
      weight = 0;
    }
    this.edges[vertex1][vertex2] = weight;
    this.edges[vertex2][vertex1] = weight;
  }
```
위 두 방식은 메모리 측면에서 보면 인접 행렬 방식은 모든 관계를 저장하기 때문에 노드 개수가 많을수록 메모리가 불필요하게 낭비된다. 반면 인접 리스트 방식은 연결된 정보만 저장하기 때문에 효율적으로 사용이 가능하다.

하지만 이와 같은 속성 때문에 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. 왜냐하면 리스트 방식에서는 연결된 데이터를 하나씩 확인해야 하기 때문이다.

특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우 인접 리스트 방식이 인접행렬에 비해 메모리 공간의 낭비가 적다. DFS는 탐색을 위해 사용 되는 탐색 알고리즘이라고 하고 깊이 우선 탐색 알고리즘이라고 했다. 이 알고리즘은 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후 다시 다른 경로로 돌아가 탐색하는 알고리즘이다. 

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다. 
3. 2번의 과정을 더이상 수행할 수 없을때 까지 반복한다.

![ex_dfs](/img/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202022-04-24%20%EC%98%A4%ED%9B%84%204.30.03.png)

위 그림에서 순서는 다음과 같다.

0 - 1 - 2 - 3 - 4

깊이 우선 탐색 알고리즘인 DFS는 스택 자료구조에 기초한다는 점에서 구현이 간단하다. 실제로는 스택을 쓰지 않아도 되며 탐색을 수행함에 있어서 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다. 또한 재귀 함수를 이용하였을 때 매우 간결하게 구현 가능하다.

```js
const DFS = (graph, startNode) => {
  const visited = [];
  let needVisit = []; 

  needVisit.push(startNode);

  while (needVisit.length !== 0) { 

    const node = needVisit.shift(); 

    if (!visited.includes(node)) { 
      visited.push(node); 
      needVisit = [...graph[node], ...needVisit];
    }
  }
  return visited;
};
```

## BFS(Breadth First Search)
너비 우선 탐색이라고도 부르며 가까운 노드부터 탐색하는 알고리즘이다. 
| 알고리즘 | 방식 | 동작원리 | 구현 방법 |
|--|--|--|--|
| BFS | 너비우선탐색 | 큐 | 큐 자료구조 이용|
| DFS | 깊이 우선 탐색 | 스택 | 재귀 함수 이용|

BFS는 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다. 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 나가게 되어, 가까운 노드부터 탐색을 진행한다. 

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

![ex_bfs](/img/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202022-04-24%20%EC%98%A4%ED%9B%84%205.45.08.png)

위 그림에서 순서는 다음과 같다.
0 - 1 - 2 - 4 - 3
너비 우선 탐색 알고리즘인 BFS는 큐 자료구조에 기초한다는 점에서 구현이 간단하다. 실제로 구현함에 있어 앞서 언급한 대로 deque 라이브러리를 사용하는 것이  좋으며 탐색을 수행함에 있어 O(N)의 시간이 소요된다. 

코딩 테스트 중 2차원 배열에서의 탐색 문제를 만나면 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다.

<br>

## 예제
N * M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 다음의 4 * 5 얼음 틀 예시에서는 아이스크림이 총 3개 생성된다.
 - 입력조건 : 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다.(1 <= N, M <= 1,000)
 - 두번째 줄부터 N + 1 번째 줄까지 얼음 틀의 형태가 주어진다.
 - 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

 - 출력 조건 : 한 번에 만들 수 있는 아이스크림의 개수를 출력한다. 
 ```js
function solution(N, M, ice){
  
}
 ```


## 문제
n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

```js
function solution(numbers, target) {
  let answer = 0;

  function dfs(depth, sum) {
    if (depth === numbers.length) {
      if (sum === target) {
        answer += 1;
      }
      return;
    }
    dfs(depth + 1, sum + numbers[depth]);
    dfs(depth + 1, sum - numbers[depth]);
  }

  dfs(0, 0);

  return answer;
}
```
1. DFS 
2. 트리라고 생각해서 트리의 깊이랑 Numbers 배열의 길이랑 비교해서 같으면 target값이랑 같은지 확인
3. 트리모양이라고 생각해서 왼쪽은 +, 오른쪽은 -
4. 트리의 깊이가 numbers배열과 같아지면 결과 값이 target이랑 비교