# 정렬(Sort)
정렬(Sorting)이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것

- 프로그램에서 데이터를 가공할 때 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많기에 정렬 알고리즘은 프로그램을 작성할 때 많이 사용되는 알고리즘 중 하나다.
- 정렬 알고리즘으로 데이터를 정렬하면 다음 장에서 배울 이진 탐색(Binary search)가 가능해진다.
- 모두 오름차순 정렬을 수행. 내림차순 정렬의 경우에는 오름차순 정렬을 수행하는 알고리즘에서 크기 비교를 반대로 수행하면 된다. => 또한 파이썬에서는 특정한 리스트의 원소를 뒤집는 메서드(Reverse)를 제공한다.

<br>

## 종류와 시간 복잡도
---|내용|시간복잡도|
|---|---|---|
|선택정렬<br>(Selection Sort)|가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, <br>그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정 반복|O(N제곱)|
|삽입정렬<br>(Quick Sort)|- 특정한 데이터를 적절한 위치에 '삽입'<br> - 보통은 비효율적이지만 정렬이 거의 되어있으면 퀵정렬보다 강력|O(N제곱)|
|퀵정렬<br>(Quick Sort)|- 가장 많이 사용되는 알고리즘 <br>-참고로 퀵정렬 만큼 빠른 정렬은 병합정렬이 존재 <br> - 기준 데이터를 설정하고 그 기준보다 큰 데이터와<br> 작은 데이터의 위치를 변경|평균 : O(NlogN)<br>최악 : O(N제곱)|
|계수정렬<br>(Count Sort)| - 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만<br> 사용할 수 있지만 매우 빠른 정렬 알고리즘| O(N+K)|
|파이썬<br>라이브러리 | - 파이썬은 기본 정렬 라이브러리인 sorted() 함수를 제공<br> - 병렬 정렬을 기반으로 만들어짐 => 정확하게는 병합정렬과 삽입정렬의<br> 아이디어를 더한 하이브리드 방식의 정렬 알고리즘<br> - 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간복잡도<br> O(NlogN)을 보장한다는 특징이 있음 . | O(NlogN)|

<br>

## 선택정렬 (Selection Sort)
데이터가 무작위로 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하면 어떨까?
<br>

동작과정 : 탐색 범위는 반복할 때마다 줄어든다. 매번 가장 작은 원소를 찾기 위해서 탐색 범위 만큼 데이터를 확인한다. 매번 선형탐색을 하는 것과 동일하다.

```js
function selectionSort (array) {
  for (let i = 0; i < array.length; i++) {
    let minIndex = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[minIndex] > array[j]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      let swap = array[minIndex];
      array[minIndex] = array[i];
      array[i] = swap;
    }
    console.log(`${i}회전: ${array}`);
  }
  return array;
}
console.log(selectionSort([7, 5, 9, 0, 3, 1, 6, 2, 4, 8]));
```
### 선택정렬의 시간복잡도
*시간 복잡도 : O(N제곱)

    선택 정렬은 기본 정렬 라이브러리나 뒤에서 다룰 알고리즘에 비해서 매우 비효율적. 그러나 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 잦으므로 형태는 알아두어야 함.
## 삽입 정렬(Insertion Sort)
'데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?'

- 삽입 정렬은 선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘

- 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬 되어 있을 때' 훨씬 효율적

- 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 바꾸는 반면 삽입 정렬은 그렇지 않음

- 삽입 정렬은 특정한 데이터를 적절한 위치에 "삽입" 한다는 의미에서 "삽입 정렬"

- 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정

- 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징

- 삽입 정렬은 두번째 데이터 부터 시작한다. 왜냐하면 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단

- 삽입 정렬의 특징으로는 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다는 점

```js

function insertionSort (array) {
  for (let i = 1; i < array.length; i++) {//두번쨰 요소부터 선택해서 앞의 요소들이랑 비교

  let cur = array[i]; // cur에서 현재 데이터 저장하고 left에 -1 넣어줌
  let left = i - 1;
    while (left >= 0 && array[left] > cur) {//while문 돌려서 left가 0보다 크거나 같고, array[left]가 cur보다 큰 경우
    array[left + 1] = array[left]; // array[left+1]에 array[left]값 넣고 left값을 하나씩 줄여가며 왼쪽과 비교
    left--;
    }
    array[left + 1] = cur;
    console.log(`${i}회전: ${array}`);
  }
  return array;
}

console.log(insertionSort([7, 5, 9, 0, 3, 1, 6, 2, 4, 8]));
```
### 삽입정렬의 시간복잡도
시간 복잡도 : O(N제곱)

    현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작
    
## 퀵정렬
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?
퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.

- 퀵 정렬에서는 피벗(pivot)이 사용된다. 피벗은 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 "기준"을 바로 피벗이라고 표현한다.

- 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것이지 미리 명시해야 하는데, 우리는 가장 대표적인 분할 방식인 호어 분할(Hoare Partition)방식을 기준으로 퀵 정렬을 설명.

- 호어 분할 방식에서는 리스트에서 첫 번째 데이터를 피벗으로 정한다.

![ex1](../../img/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202022-05-08%20%EC%98%A4%ED%9B%84%202.49.25.png)

<br>
1. 기준 원소를 고른다. 여러 가지 방법이 있겠지만 위 그림에서는 배열의 첫 번째 요소를 기준 원소로 설정했다.
2. 배열을 기준 원소보다 작은 원소의 배열과 기준 원소보다 큰 원소의 배열, 이렇게 2개의 하위 배열로 분할한다.
3. 하위 배열에 대해 재귀적으로 퀵 정렬을 호출한다.

```js

function quickSort (array) {
  if (array.length < 2) {
  return array;
}

const pivot = [array[0]];
const left = [];
const right = [];

for (let i = 1; i < array.length; i++) {
  if (array[i] < pivot) {
  left.push(array[i]);
      } else if (array[i] > pivot) {
      right.push(array[i]);
      } else {
      pivot.push(array[i]);
    }
}

  console.log(`left: ${left}, pivot: ${pivot}, right: ${right}`);
  return quickSort(left).concat(pivot, quickSort(right));
}

const sorted = quickSort([5, 7, 9, 0, 3, 1, 6, 2, 4, 8]);
console.log(sorted);
```
### 퀵 정렬의 시간 복잡도
   평균 시간 복잡도는 O(NlogN). 삽입과 선택에 비해 매우 빠르다.

    => 피벗값의 위치가 변경되어 분할이 일어날 때마다 정확히 왼쪽 리스트와 오른쪽 리스트를 절반씩 분할한다면 데이터의 개수가 n개라면 높이는 logN이 된다. (책 그림 참고)

다시말해 분할이 이루어지는 횟수가 기하급수적으로 감소하게 된다.

평균적으로는 O(NlogN)이지만 최악의 경우 시간 복잡도가 O(n제곱)
  => 데이터가 무작위로 입력되는 경우 퀵정렬을 매우 빠르게 동작하지만, 하지만 위와 같이 호어방식분할을 사용해 리스트의 가장 왼쪽 데이터를 피벗으로 삼을 때, "이미 데이터가 정렬되어 있는 경우"에는 매우 느리게 동작한다.

  ## 계수정렬(count sort)
- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘

- 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.

- "데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때"만 사용할 수 있다.

- 따라서 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기가 어렵다.

- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.

	    => 계수 정렬이 이러한 특징을 가지는 이유는 계수 정렬을 이용할 때는 "**모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언**"해야 하기 때문이다. 

```js
const arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2];
const count = Array(5).fill(0);
let sorted = [];

for(let i=0; i<arr.length; i++)
  count[arr[i]-1]++;

for(let i=0; i<count.length; i++) {
  const sortedNum = Array(count[i]).fill(i+1);
  sorted = sorted.concat(sortedNum);
}

console.log(sorted);
```
### 계수 정렬의 시간 복잡도
계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N+K)이다.
계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.

    =>데이터가 0과 999,999로 단 2개만 존재하는 경우를 생가했을때, 리스트의 크기가 100만개가 되도록 선언해야함.

## 문제
가장 큰 수
문제 설명
0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.

예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.

0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.

제한 사항
numbers의 길이는 1 이상 100,000 이하입니다.
numbers의 원소는 0 이상 1,000 이하입니다.
정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.
입출력 예

numbers | return
--|--
[6, 10, 2]|"6210"
[3, 30, 34, 5, 9]	|"9534330"

```js
function solution(numbers) { 
    const numbersString = numbers.map((num) => String(num)); //number요소 문자열로 바꿔줌
    numbersString.sort((a,b) => { // b+a숫자와 a+b숫자 비교 후 내림차순
        return parseInt(b + a) - parseInt(a + b);
    })
    const answer = numbersString.join(''); // 만들어진 배열 문자열
  return parseInt(answer).toString();
}
```
numbers 배열 문자열로 변경
문자열로 이루어진 numberString 배열 정렬하는데, 각 요소는 문자열이니깐 + 로 붙여주고, sort 메소드 a,b 가져와서 b+a a+b 숫자들을 내림차순 후 return