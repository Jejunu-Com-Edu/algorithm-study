# 그리디 알고리즘
'현재 상황에서 가장 좋아 보이는 것만을 선택하는 알고리즘'

## 그리디(Greedy)알고리즘이란?
- 가장 단순한 형태의 알고리즘
- 무조건 큰 경우대로 무조건 작은 경우대로 무조건 긴 경우대로 무조건 짧은 경우대로 등으로 극단적으로 문제에 접근
- 어느 정도 최적의 해에 근사한 값을 빠르게 구할 수 있는 알고리즘
- 특정한 상황에서는 최적의 해를 보장할 수도 있는 알고리즘

<br>

## 예제
1260원을 동전으로 거슬러주어야 할 때 가장 적은 숫자의 화폐를 이용해 거슬러 주는 경우는?
 - 무조건 큰 숫자의 화폐부터 골라서 거슬러주면 됨.

 1. 먼저 가장 큰 화폐 단위인 500원 부터 계산
 2. 이후에 100원짜리 동전으로 거슬러 줄 수 있는 경우를 계산
 3. 50원짜리, 마지막으로 10원짜리 까지 동전으로 거슬러 줄 수 있는 경우를 계산

총 6개의 동전만 거슬러주면서 이렇게 단순하게 큰 경우부터 찾는 알고리즘과 같이 간단히 탐욕적으로 문제를 풀이하는 기법을 '그리디 알고리즘'이라고 함. 

```javascript

function change(n) {
  let count = 0;
  const array = [500, 100, 50, 10];
  
  for(let coin of array) {
      count += Math.floor(n/coin); //동전 개수
      n -= coin*Math.floor(n/coin); // 남은 돈
  }
  
  return count;
}
  console.log(change(1260));
```
Math.floor를 사용하는 이유는 다른언어와 달리 자바스크립트는 타입이 따로 정의되어 있지 않기 때문에 연산을 했을 때 몫만 나오지 않고 1260/500 = 2.52 소수점까지 출력되기 때문에 Math.floor 메소드로 나머지 값을 버려주어야 한다.

(참고문서 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)

<br/>

## 시간복잡도
- 화폐종류를 K라고 하면 소스코드의 시간 복잡도는 O(K)
- 화폐의 종류만큼 반복문을 수행
- 시간 복잡도는 동전의 총 종류에만 영향
  
<br/>

## 정당성
- 탐욕적으로 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적임
- 그리디 알고리즘으로 문제의 해법을 ㅊ자았을 때는 그 해법이 정당한지 검토
- 거스름돈 문제에서 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이기 때문
- 그리디 알고리즘 문제에서는 최소한의 아이디어를 떠올리고 정당한지 검토할 수 있어야함

  
## 풀이 전략
 - 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심, 문제를 해결할 수 있는 탐욕적인 해결법이 존재하는지 고민
- 작은것에서 큰것 혹은 큰것에서 작은것으로 생각한다면 항상 최적의 해를 보장할 수 있음.

<br/>

## 문제

 프로그래머스 level1 - 체육복 문제
   
    
![ex](../../img/스크린샷%2022-04-09%오전%11.47.49.png)

<br/>

## 문제 풀이
```javascript
function solution(n, lost, reserve) {
    
    const clothes = Array(n).fill(1);
    
    lost.map((lost) => {clothes[lost-1] = 0});
    
    reserve.map((reserve) => {clothes[reserve-1] += 1});
    
    for(let i=0; i<n; i++){
        if(clothes[i] == 0 && clothes[i-1] === 2){
            clothes[i] = 1;
            clothes[i-1] = 1;
        }
        else if(clothes[i] === 0 && clothes[i+1] === 2){
            clothes[i] = 1;
            clothes[i+1] = 1;
        }
    }
    return clothes.filter(c => c > 0).length;
}
```

<br/>

 - 여벌의 체육복을 가져온 학생이 도난당했을 경우
 - 도난된 학생이 여벌의 체육복을 가져온 학생에게 빌렸을경우
 - 전체학생 수 - 체육복을 도난당하고 여벌을 못받은 학생 수

 ## 문제풀이
  - 학생들이 갖고 있는 체육복 개수를 1로 설정
  - 도난당한 학생들은 0, 여벌이 있으면 1을 더함
  - 여벌을 갖고 온 학생이 도난을 당했으면 체육복 1개를 갖고 있게됨
  - 체육복이 0개인 학생의 앞, 뒤 학생이 체육복 2개를 갖고 있을 경우 빌려와서 1개가 됨
  - 배열에서 1개 이상의 체육복을 갖고 있는 학생의 수를 구해야함

![해결](../../img/스크린샷%2022-04-09%오후%1.17.41.png)