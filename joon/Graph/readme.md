## 서로소집합

- 서로소 : 공통원소가 없는 두 집합을 의미함
  - {1, 2}, {3, 4} : 서로소에 해당함
  - {1, 2}, {2, 4} : 서로소에 해당하지 않음

##  서로소 집합 자료구조
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- 두종류의 연산을 지원함
  - 합집합 Union
      - 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  - 찾기 Find
      - 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
  - 합치기 찾기 (Union Find) 자료구조라고 불리기도 함.

### 동작과정
1. 합집합 연산을 확인하여 서로 연결된 두 노드 A, B를 확인함
    1. A, B의 루트 노드인 A’, B’를 찾음
    2. A’를 B’의 부모 노드로 설정
2. 모든 합집합 연산을 처리할 때까지 1번의 과정을 반복

ex)
1. 처리할 연산들이 주어짐
    1. Union(1, 4)
    2. Union(2, 3)
    3. Union(2, 4)
    4. Union(5, 6)
2. 각 노드들의 부모 노드를 기록하는 테이블을 생성한 뒤 처음에는 자기 자신으로 초기화 함.
      - 1->1, 2->2, … 6->6
3. Union 연산의 두 노드를 비교하여 더 작은 노드를 루트 노드로 설정한 뒤 부모 노드 테이블을 갱신함.
    1. 일반적으로는 더 큰 루트 노드가 작은 루트노드를 따르도록 하는 것이 관례임.(그렇지 않게 작성하는 방법도 있긴 하다)
    2. 이때 중요한 점은 부모노드 != 루트노드
    3. 예) 3의 경우 부모는 2이지만 루트노드는 3->2->1 이 됨.
4. 연결된 형태를 통해서 집합의 형태를 확인할 수 있음
    1. 루트노드가 같은 그룹은 하나의 집합이라고 판단할 수 있음
    2.  예시
        1. {1, 2, 3, 4} : 1
        2. {5, 6} : 5

<br>

## 연결성
- 기본적인 형태의 서로소 집합 자료 구조에서는 루트 노드에 즉시 접근할 수 없음
    - 루트 노드를 찾기 위해서 부모 테이블을 계속해서 확인하며 거슬러 올라가야 함
- 예시
    - 3의 루트를 찾는 과정 : 3-> 2-> 1

### 기본적인 서로소 집합 자료구조의 구현시 문제점
- 합집합 연산이 편향되게 수행되는 경우에 비효율이 발생할 수 있음
- 최악의 경우 찾기 함수가 모든 노드를 다 호출하여 시간복잡도가 최대 O(v) 까지 발생할 수 있음
    - 예시
        - Union(4, 5), Union(3, 4), Union(2, 3), Union(1, 2)
        - {1, 2, 3, 4, 5} 원솔르 가진 집합 1개가 존재함

<br>

### 해결방법 : 경로압축
  - 찾기 함수를 최적화 하기 위하여 경로압축을 사용할 수 있음
  - 루트노드를 찾는 과정에서 찾기함수를 재귀적으로 호출하고 부모테이블 값을 바로 갱신함
  - 결국 부모테이블의 값이 루트노드의 테이블이 되는 셈임
  - 기존 방법에서 find_parent() 함수만 아래와 같이 수정해주면 됨

<br>

### 서로소 집합을 활용한 사이클 판별
- 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있음
    - 방향 그래프에서 사이클 여부는 DFS 를 이용하여 판별할 수 있음

1. 각 간선을 하나씩 확인하며 두 노드의 루트 노드를 확인함
    1. 루트 노드가 다르다면 두 노드에 대해서 합집합 연산을 수행
    2. 루트 노드가 서로 같다면 사이클 발생
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복함

## 최소신장트리 알고리즘
최소신장트리

- 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프

![ex](../../img/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202022-06-05%20%EC%98%A4%EC%A0%84%2012.36.32.png)

- 실제 문제에서의 응용

![ex](../../img/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202022-06-05%20%EC%98%A4%EC%A0%84%2012.36.40.png)

<br>

## 크루스칼 알고리즘

- 대표적인 최소 신장 트리 알고리즘
- 그리디 알고리즘으로 분류됨
- 동작과정
    1. 간선 데이터를 비용에 따라서 오름차순으로 정렬함
    2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인함
        1. 사이클 발생할 경우 : 스킵함
        2. 사이클 발생하지 않을 경우 : 최소 신장 트리에 포함시킴
    3. 모든 간선에 대래서 2번의 과정을 반복함


### 크루스칼 알고리즘 동작과정
1. 그래프의 모든 간선 정보에 대하여 오름차순으로 정렬 수행
    1. 참고 : 최종적으로 만들어지는 최소신장트리의 간선 개수 = 전체 노드의 개수 -1
    2. 기본적으로 트리가 가지는 특징이며 사이클도 가지지 않음
2. 가장 비용이 작은 간선부터 확인함
3. 차례대로 비용이 작은 순서부터 반복함
4. 같은 집합에 속해있지 않으면 유니온 함수 호출하여 집합 합치기
5. 이미 같은 집합에 속해있다면 스킵
6. 마지막으로 최소 신장트리가 만들어지만 그에 포함된 간선의 비용만 더하면 최소 비용을 산출할 수 있음


### 크루스칼 알고리즘의 성능 분석
- 간선의 개수가 E개 일때 O(ElogE)의 시간복잡도를 가짐
- 이 알고리즘에서 가장 많은 시간이 요구되는 곳은 간선을 정렬하는 부분
- 표준 라이브러리를 이용해서 E개의 데이터를 정렬하기 위한 시간 복잡도는 O(ElogE)

<br>

## 위상정렬
- 사이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
- 예를들면 선수과목을 고려한 학습순서설정 과 같은 문제에서 사용될 수 있다.
    - 세 과목을 듣는 적절한 학습 순서는 다음과 같다!
    - 자료구조 -> 알고리즘 -> 고급 알고리즘

![ex](../../img/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202022-06-05%20%EC%98%A4%EC%A0%84%2012.36.40.png)

<br>

- 진입차수 : 특정한 노드로 들어오는 간선의 개수
- 진출차수 : 특정한 노드에서 나가는 간선의 개수

<br>

## 위상정렬 알고리즘 동작과정
- 방법 : DFS, 큐
- 큐를 이용할 때
    1. 진입차수가 0인 모든 노드를 큐에 넣는다.
    2. 큐가 빌때까지 다음의 과정을 반복한다.
        1. 큐에서 원소를 꺼내서 해당 노드에서 나가는 간선을 그래프에서 제거한다.
        2. 새롭게 진입차수가 0이된 노드를 큐에 넣는다.
    3. 각 노드가 큐에 들어온 순서 = 위상정렬 수행한 결과

<br>

1. 위상정렬수행할 그래프 준비하기
    1. 이때 그래프는 사이클이 없는 방향 그래프여야 함
2. 가장 먼저 진입차수가 0인 모든 노드를 큐에 넣음
    1. 1번 노드가 큐에 삽입
3. 이제 큐에서 노드 1을 꺼내고 여기에서 나가는 간선을 제거
    1. 1->2, 1->5 간선이 제거됨
    2. 이제 2, 5의 진입차수가 0이 된다. 이들을 큐에 넣음
4. 큐에서 다시 노드를 꺼낸다. 일반적으로 더 작은 노드를 꺼내므로 2가 나오게 됨
    1. 2에서 나가는 간선을 제거한다. 2->3, 2->6 이 제거
    2. 이제 3번 노드가 진입차수가 0으로 큐에 삽입됨
5. 5번 노드를 꺼냄
    1. 5->6으로 가는 간선이 제거됨
    2. 6번 노드도 진입차수가 0으로 큐에 삽입됨
6. 3번 노드를 꺼냄
    1. 3->4 간선이 제거됨
    2. 진입차수가 0이 된 노드가 없으므로 스킵함
7. 6번 노드를 꺼냄
    1. 6->4 간선이 제거됨
    2. 4번의 진입차수가 0이 되었다. 4번 노드를 큐에 넣음
8. 4번 노드를 꺼냄
    1. 4->7 간선을 제거
    2. 7번노드도 진입차수 0으로 큐에 삽입
9. 7번 노드를 꺼냄
    1. 7-> 간선이 없고 진입차수가 0이된 노드가 없으므로 종료
10. 큐에 삽입된 전체 노드의 순서
    - 1->2->5->3->6->4->7

<br>

### 위상정렬의 특징

- 현재의 그래프가 사이클을 갖지 않은 방향그래프일때만 수행할 수 있음
    - DAG : direct acyclic graph : 순환하지 않는 방향 그래프
- 여러가지의 답이 존재할 수 있음
    - 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우라면 여러가지 답이 존재할 수 있음
- 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있음
    - 사이클에 퐘된 원소 중에서 어떤 원소도 큐에 들어가지 못하기 때문임
- 스택을 활용한 DFS 를 이용해서 위상정렬을 수행할수도 있음