## 서로소집합

- 서로소 : 공통원소가 없는 두 집합을 의미함
  - {1, 2}, {3, 4} : 서로소에 해당함
  - {1, 2}, {2, 4} : 서로소에 해당하지 않음

##  서로소 집합 자료구조
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- 두종류의 연산을 지원함
  - 합집합 Union
      - 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  - 찾기 Find
      - 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
  - 합치기 찾기 (Union Find) 자료구조라고 불리기도 함.

### 동작과정
1. 합집합 연산을 확인하여 서로 연결된 두 노드 A, B를 확인함
    1. A, B의 루트 노드인 A’, B’를 찾음
    2. A’를 B’의 부모 노드로 설정
2. 모든 합집합 연산을 처리할 때까지 1번의 과정을 반복

ex)
1. 처리할 연산들이 주어짐
    1. Union(1, 4)
    2. Union(2, 3)
    3. Union(2, 4)
    4. Union(5, 6)
2. 각 노드들의 부모 노드를 기록하는 테이블을 생성한 뒤 처음에는 자기 자신으로 초기화 함.
      - 1->1, 2->2, … 6->6
3. Union 연산의 두 노드를 비교하여 더 작은 노드를 루트 노드로 설정한 뒤 부모 노드 테이블을 갱신함.
    1. 일반적으로는 더 큰 루트 노드가 작은 루트노드를 따르도록 하는 것이 관례임.(그렇지 않게 작성하는 방법도 있긴 하다)
    2. 이때 중요한 점은 부모노드 != 루트노드
    3. 예) 3의 경우 부모는 2이지만 루트노드는 3->2->1 이 됨.
4. 연결된 형태를 통해서 집합의 형태를 확인할 수 있음
    1. 루트노드가 같은 그룹은 하나의 집합이라고 판단할 수 있음
    2.  예시
        1. {1, 2, 3, 4} : 1
        2. {5, 6} : 5

<br>

## 연결성
- 기본적인 형태의 서로소 집합 자료 구조에서는 루트 노드에 즉시 접근할 수 없음
    - 루트 노드를 찾기 위해서 부모 테이블을 계속해서 확인하며 거슬러 올라가야 함
- 예시
    - 3의 루트를 찾는 과정 : 3-> 2-> 1

### 기본적인 서로소 집합 자료구조의 구현시 문제점
- 합집합 연산이 편향되게 수행되는 경우에 비효율이 발생할 수 있음
- 최악의 경우 찾기 함수가 모든 노드를 다 호출하여 시간복잡도가 최대 O(v) 까지 발생할 수 있음
    - 예시
        - Union(4, 5), Union(3, 4), Union(2, 3), Union(1, 2)
        - {1, 2, 3, 4, 5} 원솔르 가진 집합 1개가 존재함

<br>

### 해결방법 : 경로압축
  - 찾기 함수를 최적화 하기 위하여 경로압축을 사용할 수 있음
  - 루트노드를 찾는 과정에서 찾기함수를 재귀적으로 호출하고 부모테이블 값을 바로 갱신함
  - 결국 부모테이블의 값이 루트노드의 테이블이 되는 셈임
  - 기존 방법에서 find_parent() 함수만 아래와 같이 수정해주면 됨

<br>

### 서로소 집합을 활용한 사이클 판별
- 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있음
    - 방향 그래프에서 사이클 여부는 DFS 를 이용하여 판별할 수 있음

1. 각 간선을 하나씩 확인하며 두 노드의 루트 노드를 확인함
    1. 루트 노드가 다르다면 두 노드에 대해서 합집합 연산을 수행
    2. 루트 노드가 서로 같다면 사이클 발생
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복함

## 최소신장트리 알고리즘
최소신장트리

- 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
[ex](../../img)